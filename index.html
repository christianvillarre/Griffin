<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loader – Center Square + LTR Reveal + Centered Pair</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111111;

      --square: 96;   /* px */
      --gap: 8;       /* px */
      --rectW: 170;   /* px */
      --rectH: 96;    /* px */

      --ovalW: 800;   /* wider side images */
    }
    :root{
      --rectW: 254;  /* overrides above rectW */
      --rectH: 96;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow:auto;
    }

    /* ---------- Site (behind loader) ---------- */
    #site{
      min-height: 260vh;
      padding: 0;
    }
    .hero{
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;

      background: url("images/redorange.png") center center / cover no-repeat;
      position: relative;
    }

    .hero::before{
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.012);
    }

    .hero > *{
      position: relative;
      z-index: 2;
      color: white;
    }

    .spacer{
      padding: 0 clamp(18px, 5vw, 80px);
    }
    .hero h1{ font-size: clamp(34px, 4vw, 56px); line-height:1.05; margin:0 0 12px; letter-spacing:-0.02em; }
    .hero p{ margin:0 0 20px; font-size:18px; opacity:.78; max-width:65ch; }

    .card-row{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:16px;
      margin-top:28px;
    }
    .card{
      border:1px solid rgba(0,0,0,.12);
      border-radius:16px;
      padding:16px;
      background:rgba(0,0,0,.02);
      min-height:120px;
    }
    .spacer{
      height:120vh;
      max-width:1000px;
      margin:24px auto;
      border-radius:18px;
      background: linear-gradient(to bottom, rgba(0,0,0,.05), rgba(0,0,0,0));
      border:1px dashed rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(0,0,0,.55);
      font-weight:600;
      letter-spacing:.02em;
    }
    @media (max-width: 900px){
      .card-row{ grid-template-columns: 1fr; }
    }

    /* ---------- SVG Loader Overlay ---------- */
    #loaderSvg{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      z-index:9999;
      display:block;
      pointer-events:none;
    }
    
  </style>
</head>

<body>
  <main id="site">
    <section class="hero">
      <h1>Your Website</h1>
      <p>During loader you shouldn’t be able to scroll. After loader is gone, scrolling should work.</p>

      <div class="card-row">
        <div class="card"><strong>Card 1</strong><br/>Some content…</div>
        <div class="card"><strong>Card 2</strong><br/>Some content…</div>
        <div class="card"><strong>Card 3</strong><br/>Some content…</div>
      </div>
    </section>

    <div class="spacer">SCROLL TEST ZONE</div>
    <div class="spacer">MORE SCROLL TEST</div>
  </main>

  <!-- ✅ One SVG "sheet" (white + loader content) that gets cut out by expanding window -->
  <svg id="loaderSvg" aria-hidden="true">
    <defs>
      <!-- Window mask: white = keep sheet, black = hole -->
      <mask id="revealMask" maskUnits="userSpaceOnUse">
        <rect id="maskBase" x="0" y="0" width="1" height="1" fill="white"></rect>
        <rect id="maskWindow" x="0" y="0" width="0" height="0" fill="black"></rect>
      </mask>

      <!-- Clip to mimic your .behind-clip -->
      <clipPath id="behindClip">
        <rect id="behindClipRect" x="0" y="0" width="0" height="0"></rect>
      </clipPath>

      <!-- Clip for square reveal (animate width for left->right reveal) -->
      <clipPath id="squareClip">
        <rect id="squareClipRect" x="0" y="0" width="0" height="0"></rect>
      </clipPath>
    </defs>

    <g id="sheet" mask="url(#revealMask)">
      <!-- White background sheet -->
      <rect id="cover" x="0" y="0" width="1" height="1" fill="#ffffff"></rect>

      <!-- Side ovals as images -->
      <image id="ovalLImg" href="images/img3.png" x="0" y="0" width="180" height="1" preserveAspectRatio="none"></image>
      <image id="ovalRImg" href="images/img4.png" x="0" y="0" width="180" height="1" preserveAspectRatio="none"></image>

      <!-- Center stage -->
      <g id="stage">
        <!-- Rectangle (behind) clipped -->
        <g clip-path="url(#behindClip)">
          <image id="rectImg" href="images/Griffin Logo Text.png" x="0" y="0" width="400" height="96" preserveAspectRatio="none"></image>
        </g>

        <!-- Square reveals left->right via clipPath -->
        <image id="squareImg" href="images/Griffin Icon.png"
               x="0" y="0" width="96" height="96"
               preserveAspectRatio="none"
               clip-path="url(#squareClip)"></image>
      </g>
    </g>
  </svg>

  <script>
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const easeOut = (t) => 1 - Math.pow(1 - t, 4.5);

    // ===== Mask easing helpers (pick per phase) =====
const easeLinear = (t) => t;

// smooth / premium (slow settle)
const easeSoftOut = (t) => 1 - Math.pow(1 - t, 4.5);

// snappier
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

// cinematic slow finish
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 6);

// subtle overshoot (no bounce)
const easeOutBack = (t) => {
  const c1 = 1.70158;
  const c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
};

    function lockScroll(){
      const y = window.scrollY || document.documentElement.scrollTop || 0;
      document.body.dataset.scrollY = String(y);
      document.body.style.position = "fixed";
      document.body.style.top = `-${y}px`;
      document.body.style.left = "0";
      document.body.style.right = "0";
      document.body.style.width = "100%";
    }
    function unlockScroll(){
      const y = parseInt(document.body.dataset.scrollY || "0", 10);
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.left = "";
      document.body.style.right = "";
      document.body.style.width = "";
      document.body.removeAttribute("data-scroll-y");
      window.scrollTo(0, y);
    }

    function animateAttrs(el, from, to, duration, easeFn = (x)=>x){
      return new Promise(resolve=>{
        const t0 = performance.now();
        function frame(now){
          const t = Math.min(1, (now - t0)/duration);
          const e = easeFn(t);

          if ("x" in from) el.setAttribute("x", from.x + (to.x - from.x)*e);
          if ("y" in from) el.setAttribute("y", from.y + (to.y - from.y)*e);
          if ("w" in from) el.setAttribute("width",  from.w + (to.w - from.w)*e);
          if ("h" in from) el.setAttribute("height", from.h + (to.h - from.h)*e);

          // ✅ transform animation: translateX only unless scale explicitly provided
          if ("tx" in from || "sx" in from || "sy" in from || "tx" in to || "sx" in to || "sy" in to){
            const tx = (from.tx ?? 0) + ((to.tx ?? 0) - (from.tx ?? 0))*e;

            const hasScale = ("sx" in from) || ("sy" in from) || ("sx" in to) || ("sy" in to);
            if (hasScale){
              const sx = (from.sx ?? 1) + ((to.sx ?? 1) - (from.sx ?? 1))*e;
              const sy = (from.sy ?? 1) + ((to.sy ?? 1) - (from.sy ?? 1))*e;
              el.setAttribute("transform", `translate(${tx},0) scale(${sx},${sy})`);
            } else {
              el.setAttribute("transform", `translate(${tx},0)`);
            }
          }

          if(t < 1) requestAnimationFrame(frame);
          else resolve();
        }
        requestAnimationFrame(frame);
      });
    }

    function sizeScene(){
      const svg = document.getElementById("loaderSvg");
      const w = window.innerWidth;
      const h = window.innerHeight;
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

      const root = getComputedStyle(document.documentElement);
      const sq    = parseFloat(root.getPropertyValue("--square")) || 96;
      const gap   = parseFloat(root.getPropertyValue("--gap")) || 8;
      const rectW = parseFloat(root.getPropertyValue("--rectW")) || 170;
      const rectH = parseFloat(root.getPropertyValue("--rectH")) || 96;
      const ovalW = parseFloat(root.getPropertyValue("--ovalW")) || 480;

      // base mask + cover
      const maskBase = document.getElementById("maskBase");
      const cover = document.getElementById("cover");
      maskBase.setAttribute("width", w);
      maskBase.setAttribute("height", h);
      cover.setAttribute("width", w);
      cover.setAttribute("height", h);

      // Stage 1: square alone centered
      const sqX = (w - sq)/2;
      const sqY = (h - sq)/2;

      // Stage 2: centered group (square + gap + rect)
      const groupW  = sq + gap + rectW;
      const groupH  = Math.max(sq, rectH);
      const gxGroup = (w - groupW)/2;
      const gyGroup = (h - groupH)/2;

      // square image
      const squareImg = document.getElementById("squareImg");
      squareImg.setAttribute("x", sqX);
      squareImg.setAttribute("y", sqY);
      squareImg.setAttribute("width", sq);
      squareImg.setAttribute("height", sq);

      // square clip rect (we animate width from 0 -> sq)
      const squareClipRect = document.getElementById("squareClipRect");
      squareClipRect.setAttribute("x", sqX);
      squareClipRect.setAttribute("y", sqY);
      squareClipRect.setAttribute("width", sq);
      squareClipRect.setAttribute("height", sq);

      // rectangle image initial position (fully left, hidden behind) based on GROUP position
      const rectImg = document.getElementById("rectImg");
      rectImg.setAttribute("width", rectW);
      rectImg.setAttribute("height", rectH);
      rectImg.setAttribute("x", gxGroup - rectW);
      rectImg.setAttribute("y", gyGroup);

      // behind clip region = ONLY to the right of the square in final grouped layout
      const behindClipRect = document.getElementById("behindClipRect");
      behindClipRect.setAttribute("x", gxGroup + sq);
      behindClipRect.setAttribute("y", gyGroup);
      behindClipRect.setAttribute("width", gap + rectW);
      behindClipRect.setAttribute("height", sq);

      // ovals images: size to viewport height
      const ovalLImg = document.getElementById("ovalLImg");
      const ovalRImg = document.getElementById("ovalRImg");
      ovalLImg.setAttribute("width", ovalW);
      ovalLImg.setAttribute("height", h);
      ovalLImg.setAttribute("x", 0);
      ovalLImg.setAttribute("y", 0);

      ovalRImg.setAttribute("width", ovalW);
      ovalRImg.setAttribute("height", h);
      ovalRImg.setAttribute("x", w - ovalW);
      ovalRImg.setAttribute("y", 0);

      return { w, h, sq, gap, rectW, rectH, ovalW, sqX, sqY, gxGroup, gyGroup };
    }

    (async function run(){
      lockScroll();

      let S = sizeScene();
      const onResize = () => { S = sizeScene(); };
      window.addEventListener("resize", onResize, { passive:true });

      const maskWindow = document.getElementById("maskWindow");
      maskWindow.setAttribute("x", 0);
      maskWindow.setAttribute("y", 0);
      maskWindow.setAttribute("width", 0);
      maskWindow.setAttribute("height", 0);

      const squareImg      = document.getElementById("squareImg");
      const squareClipRect = document.getElementById("squareClipRect");
      const rectImg        = document.getElementById("rectImg");
      const ovalLImg       = document.getElementById("ovalLImg");
      const ovalRImg       = document.getElementById("ovalRImg");

      // ✅ ovals start offscreen (slide in from sides only)
      ovalLImg.setAttribute("transform", `translate(${-S.ovalW},0)`);
      ovalRImg.setAttribute("transform", `translate(${ S.ovalW},0)`);

      // Start square reveal: clip width 0 (left edge fixed)
      // Start square reveal: bottom -> top
      squareClipRect.setAttribute("x", S.sqX);
      squareClipRect.setAttribute("y", S.sqY + S.sq); // start at bottom
      squareClipRect.setAttribute("width", S.sq);
      squareClipRect.setAttribute("height", 0);

      // 1) reveal square image BOTTOM -> TOP
      await animateAttrs(
        squareClipRect,
        { x: S.sqX, y: S.sqY + S.sq, w: S.sq, h: 0 },
        { x: S.sqX, y: S.sqY,        w: S.sq, h: S.sq },
        1400,
        (t)=>t
      );

      await sleep(120);

      // 2) square moves from centered-alone to become the left item of a centered pair
      const sqToX   = S.gxGroup;
      const rectToX = S.gxGroup + S.sq + S.gap;
      const moveDuration = 900;

      const moveSquare = Promise.all([
        animateAttrs(squareImg,
          { x:S.sqX, y:S.sqY, w:S.sq, h:S.sq },
          { x:sqToX, y:S.gyGroup, w:S.sq, h:S.sq },
          moveDuration,
          easeOut
        ),
        animateAttrs(squareClipRect,
          { x:S.sqX, y:S.sqY, w:S.sq, h:S.sq },
          { x:sqToX, y:S.gyGroup, w:S.sq, h:S.sq },
          moveDuration,
          easeOut
        )
      ]);

      const moveRect = animateAttrs(
        rectImg,
        { x:S.gxGroup - S.rectW, y:S.gyGroup, w:S.rectW, h:S.rectH },
        { x:rectToX,             y:S.gyGroup, w:S.rectW, h:S.rectH },
        moveDuration,
        easeOut
      );

      // 3) ✅ ovals slide in during stage2 (no scaling)
      const ovalsIn = Promise.all([
        animateAttrs(ovalLImg, { tx:-S.ovalW }, { tx:0 }, 1100, easeOut),
        animateAttrs(ovalRImg, { tx: S.ovalW }, { tx:0 }, 1100, easeOut),
      ]);

      await Promise.all([moveSquare, moveRect, ovalsIn]);

  

      // 4) MASK: 2 phases with per-phase control
const startSize = 16;

// ---- CONFIG YOU EDIT ----
const maskPhase1 = {
  vw: 0.70,
  vh: 0.25,
  duration: 750,
  ease: easeSoftOut, // or easeOutCubic
  hold: 120,
  overshoot: 0
};

const maskPhase2 = {
  duration: 950,
  ease: easeOutQuint, // or easeSoftOut
  overshoot: 0
};
// -------------------------

const midW = S.w * maskPhase1.vw;
const midH = S.h * maskPhase1.vh;

const midX = (S.w - midW) / 2;
const midY = (S.h - midH) / 2;

// Phase 1 (open to mid size)
await animateAttrs(
  maskWindow,
  { x:(S.w-startSize)/2, y:(S.h-startSize)/2, w:startSize, h:startSize },
  { x:midX, y:midY, w:midW, h:midH },
  maskPhase1.duration,
  maskPhase1.ease
);

// Optional overshoot settle for phase 1
if (maskPhase1.overshoot > 0){
  const ow = midW * (1 + maskPhase1.overshoot);
  const oh = midH * (1 + maskPhase1.overshoot);
  await animateAttrs(
    maskWindow,
    { x:midX, y:midY, w:midW, h:midH },
    { x:(S.w-ow)/2, y:(S.h-oh)/2, w:ow, h:oh },
    Math.max(180, maskPhase1.duration * 0.22),
    easeOutCubic
  );
  await animateAttrs(
    maskWindow,
    { x:(S.w-ow)/2, y:(S.h-oh)/2, w:ow, h:oh },
    { x:midX, y:midY, w:midW, h:midH },
    Math.max(180, maskPhase1.duration * 0.22),
    easeSoftOut
  );
}

if ((maskPhase1.hold ?? 0) > 0) await sleep(maskPhase1.hold);

// Phase 2 (expand to full screen)
await animateAttrs(
  maskWindow,
  { x:midX, y:midY, w:midW, h:midH },
  { x:0, y:0, w:S.w, h:S.h },
  maskPhase2.duration,
  maskPhase2.ease
);

// Optional overshoot settle for phase 2 (rare, but available)
if (maskPhase2.overshoot > 0){
  const ow2 = S.w * (1 + maskPhase2.overshoot);
  const oh2 = S.h * (1 + maskPhase2.overshoot);
  await animateAttrs(
    maskWindow,
    { x:0, y:0, w:S.w, h:S.h },
    { x:(S.w-ow2)/2, y:(S.h-oh2)/2, w:ow2, h:oh2 },
    Math.max(160, maskPhase2.duration * 0.18),
    easeOutCubic
  );
  await animateAttrs(
    maskWindow,
    { x:(S.w-ow2)/2, y:(S.h-oh2)/2, w:ow2, h:oh2 },
    { x:0, y:0, w:S.w, h:S.h },
    Math.max(160, maskPhase2.duration * 0.22),
    easeSoftOut
  );
}

      window.removeEventListener("resize", onResize);
      document.getElementById("loaderSvg").remove();
      unlockScroll();
    })();
  </script>
</body>
</html>